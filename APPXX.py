import os
import time
import shutil
import subprocess
import math
import ctypes
import threading
import tkinter as tk
from tkinter import filedialog, messagebox
from tkinter import ttk
import tkinter.font as tkFont
import requests
from packaging import version
from sam_translate.sam_translate import set_root, set_sam_translate_globals, create_sam_translate, create_sam_mini_chat
from config import load_config, save_config

try:
    from send2trash import send2trash
except ImportError:
    send2trash = None

try:
    import psutil
except ImportError:
    psutil = None

from PIL import Image, ImageChops, ImageTk
from ctypes import wintypes
from autoit_module import auto_it_function

# Load c·∫•u h√¨nh
config = load_config()
XAI_API_KEY = config.get("xai_api_key", "")
CHATGPT_API_KEY = config.get("chatgpt_api_key", "")
LLM_API_KEY = config.get("llm_api_key", "")
TRANSLATION_ONLY = config.get("translation_only", True)
DEFAULT_TARGET_LANG = config.get("default_target_lang", "vi")
DEFAULT_TELEGRAM_PATH = config.get("telegram_path", "")
CURRENT_VERSION = "1.05"
GITHUB_USER = "nunerit"
GITHUB_REPO = "TelegramAuto"
VERSION_INFO = "Version 1.0.5 - Copyright SAMADS"
MARKER_IMAGE_PATH = os.path.join(os.getcwd(), "marker_image.png")
arrange_width = config.get("arrange_width", 500)
arrange_height = config.get("arrange_height", 504)

# Th∆∞ vi·ªán Windows API
user32 = ctypes.windll.user32

# H√†m l·∫•y handle c·ª≠a s·ªï t·ª´ PID
def get_window_handle_by_pid(pid):
    handles = []
    @ctypes.WINFUNCTYPE(ctypes.c_bool, ctypes.c_int, ctypes.c_int)
    def enum_callback(hwnd, lParam):
        if user32.IsWindow(hwnd) and user32.IsWindowVisible(hwnd):
            window_pid = wintypes.DWORD()
            user32.GetWindowThreadProcessId(hwnd, ctypes.byref(window_pid))
            if window_pid.value == pid:
                handles.append(hwnd)
        return True
    user32.EnumWindows(enum_callback, 0)
    return handles[0] if handles else None

# H√†m ch·ª•p ·∫£nh c·ª≠a s·ªï
def capture_window(hwnd):
    gdi32 = ctypes.windll.gdi32
    rect = wintypes.RECT()
    user32.GetWindowRect(hwnd, ctypes.byref(rect))
    width = rect.right - rect.left
    height = rect.bottom - rect.top
    hwindc = user32.GetWindowDC(hwnd)
    srcdc = gdi32.CreateCompatibleDC(hwindc)
    bmp = gdi32.CreateCompatibleBitmap(hwindc, width, height)
    gdi32.SelectObject(srcdc, bmp)
    result = user32.PrintWindow(hwnd, srcdc, 2)
    if result != 1:
        print("Consolog [WARNING]: PrintWindow kh√¥ng th√†nh c√¥ng ho·∫∑c ch·ªâ ch·ª•p ƒë∆∞·ª£c 1 ph·∫ßn.")

    class BITMAPINFOHEADER(ctypes.Structure):
        _fields_ = [
            ("biSize", ctypes.c_uint32),
            ("biWidth", ctypes.c_int32),
            ("biHeight", ctypes.c_int32),
            ("biPlanes", ctypes.c_uint16),
            ("biBitCount", ctypes.c_uint16),
            ("biCompression", ctypes.c_uint32),
            ("biSizeImage", ctypes.c_uint32),
            ("biXPelsPerMeter", ctypes.c_int32),
            ("biYPelsPerMeter", ctypes.c_int32),
            ("biClrUsed", ctypes.c_uint32),
            ("biClrImportant", ctypes.c_uint32),
        ]

    bmi = BITMAPINFOHEADER()
    bmi.biSize = ctypes.sizeof(BITMAPINFOHEADER)
    bmi.biWidth = width
    bmi.biHeight = -height
    bmi.biPlanes = 1
    bmi.biBitCount = 32
    bmi.biCompression = 0

    buffer_len = width * height * 4
    buffer = ctypes.create_string_buffer(buffer_len)
    _ = gdi32.GetDIBits(srcdc, bmp, 0, height, buffer, ctypes.byref(bmi), 0)

    image = Image.frombuffer('RGBA', (width, height), buffer, 'raw', 'BGRA', 0, 1)

    gdi32.DeleteObject(bmp)
    gdi32.DeleteDC(srcdc)
    user32.ReleaseDC(hwnd, hwindc)
    return image

# T·ª´ ƒëi·ªÉn ng√¥n ng·ªØ
languages = {
    "vi": {
        "title": "C√¥ng c·ª• T·ª± ƒë·ªông Telegram",
        "setting": "‚öôÔ∏è Setting",
        "close_telegram": "‚ùå ƒê√≥ng All Telegram",
        "arrange_telegram": "üü£ S·∫Øp x·∫øp Telegram",
        "check_update": "üîÑ Check for Updates",
        "log_label": "Ti·∫øn tr√¨nh:",
        "telegram_path_label": "ƒê∆∞·ªùng d·∫´n Telegram:",
        "lang_select_title": "Ch·ªçn ng√¥n ng·ªØ",
        "lang_vi": "Ti·∫øng Vi·ªát",
        "lang_en": "English",
        "lang_zh": "‰∏≠Êñá",
        "msg_error_path": "ƒê∆∞·ªùng d·∫´n kh√¥ng h·ª£p l·ªá!",
        "close_result": "ƒê√≥ng All Telegram:\nƒê√£ ƒë√≥ng: {closed}\nL·ªói: {errors}",
        "arrange_result": "ƒê√£ s·∫Øp x·∫øp {count} c·ª≠a s·ªï Telegram.",
        "update_available": "Phi√™n b·∫£n {version} c√≥ s·∫µn. B·∫°n c√≥ mu·ªën c·∫≠p nh·∫≠t kh√¥ng?",
        "no_updates": "B·∫°n ƒë√£ c√≥ phi√™n b·∫£n m·ªõi nh·∫•t.",
        "update_error": "L·ªói ki·ªÉm tra c·∫≠p nh·∫≠t.",
        "close_result_title": "K·∫øt qu·∫£ ƒë√≥ng",
        "save_telegram_path": "üíæ L∆∞u Telegram Path"
    },
    "en": {
        "title": "Telegram Auto Tool",
        "setting": "‚öôÔ∏è Setting",
        "close_telegram": "‚ùå Close All Telegram",
        "arrange_telegram": "üü£ Arrange Telegram",
        "check_update": "üîÑ Check for Updates",
        "log_label": "Log:",
        "telegram_path_label": "Telegram Path:",
        "lang_select_title": "Select Language",
        "lang_vi": "Ti·∫øng Vi·ªát",
        "lang_en": "English",
        "lang_zh": "‰∏≠Êñá",
        "msg_error_path": "Invalid path!",
        "close_result": "Close All Telegram:\nClosed: {closed}\nErrors: {errors}",
        "arrange_result": "Arranged {count} Telegram windows.",
        "update_available": "Version {version} is available. Do you want to update?",
        "no_updates": "You already have the latest version.",
        "update_error": "Error checking for updates.",
        "close_result_title": "Close Result",
        "save_telegram_path": "üíæ Save Telegram Path"
    },
    "zh": {
        "title": "Telegram Ëá™Âä®Â∑•ÂÖ∑",
        "setting": "‚öôÔ∏è Setting",
        "close_telegram": "‚ùå ÂÖ≥Èó≠ÊâÄÊúâ Telegram",
        "arrange_telegram": "üü£ ÊéíÂàó Telegram",
        "check_update": "üîÑ Ê£ÄÊü•Êõ¥Êñ∞",
        "log_label": "Log:",
        "telegram_path_label": "Telegram Path:",
        "lang_select_title": "Select Language",
        "lang_vi": "Ti·∫øng Vi·ªát",
        "lang_en": "English",
        "lang_zh": "‰∏≠Êñá",
        "msg_error_path": "Invalid path!",
        "close_result": "Close All Telegram:\nClosed: {closed}\nErrors: {errors}",
        "arrange_result": "Arranged {count} Telegram windows.",
        "update_available": "Version {version} is available. Do you want to update?",
        "no_updates": "You already have the latest version.",
        "update_error": "Error checking for updates.",
        "close_result_title": "Close Result",
        "save_telegram_path": "üíæ Save Telegram Path"
    }
}

lang = {}

# Ki·ªÉm tra th∆∞ vi·ªán psutil
if not psutil:
    print("Consolog: C·∫£nh b√°o - psutil ch∆∞a ƒë∆∞·ª£c c√†i ƒë·∫∑t! Vui l√≤ng c√†i b·∫±ng 'pip install psutil' ƒë·ªÉ check live qua PID.")

# H√†m c·∫£nh b√°o tr∆∞·ªõc khi check live
def warn_check_live():
    warning_msg = (
        "„ÄêTi·∫øng Vi·ªát„Äë: ƒê·ªÉ ƒë·∫£m b·∫£o t√≠nh nƒÉng Check live ho·∫°t ƒë·ªông ch√≠nh x√°c v√† hi·ªáu qu·∫£, vui l√≤ng ƒë√≥ng t·∫•t c·∫£ c√°c phi√™n b·∫£n Telegram ƒëang ch·∫°y tr√™n m√°y t√≠nh c·ªßa b·∫°n. B·∫°n c√≥ mu·ªën ƒë√≥ng ch√∫ng ngay b√¢y gi·ªù?\n"
        "„ÄêEnglish„Äë: To ensure the Check live feature works accurately and efficiently, please close all running Telegram instances on your computer. Would you like to close them now?\n"
        "„Äê‰∏≠Êñá„Äë: ‰∏∫‰∫ÜÁ°Æ‰øù 'Check live' ÂäüËÉΩÂáÜÁ°ÆÈ´òÊïàÂú∞ËøêË°åÔºåËØ∑ÂÖ≥Èó≠ÊÇ®ÁîµËÑë‰∏äÊâÄÊúâÊ≠£Âú®ËøêË°åÁöÑ Telegram Á®ãÂ∫è„ÄÇÊÇ®ÊòØÂê¶Â∏åÊúõÁ´ãÂç≥ÂÖ≥Èó≠ÂÆÉ‰ª¨Ôºü"
    )
    res = messagebox.askyesno("C·∫£nh b√°o", warning_msg)
    if res:
        close_all_telegram_threaded()
    check_live_window()

# H√†m t·ª± ƒë·ªông ƒë√≥ng Telegram
def auto_close_telegram():
    print("Consolog: ƒêang l·∫•y danh s√°ch ti·∫øn tr√¨nh Telegram...")
    try:
        result = subprocess.run(
            ["tasklist", "/FI", "IMAGENAME eq Telegram.exe", "/FO", "CSV"],
            capture_output=True, text=True
        )
        output = result.stdout.strip().splitlines()
        pids = []
        for line in output[1:]:
            parts = line.replace('"', '').split(',')
            if len(parts) >= 2:
                pid = parts[1].strip()
                pids.append(pid)
                print(f"Consolog: T√¨m th·∫•y ti·∫øn tr√¨nh Telegram v·ªõi PID: {pid}")
        for pid in pids:
            print(f"Consolog: ƒêang ƒë√≥ng ti·∫øn tr√¨nh v·ªõi PID: {pid}")
            subprocess.run(["taskkill", "/F", "/PID", pid], capture_output=True, text=True)
            time.sleep(0.25)
        while True:
            result = subprocess.run(
                ["tasklist", "/FI", "IMAGENAME eq Telegram.exe", "/FO", "CSV"],
                capture_output=True, text=True
            )
            lines = result.stdout.strip().splitlines()
            if len(lines) <= 1:
                print("Consolog: T·∫•t c·∫£ ti·∫øn tr√¨nh Telegram ƒë√£ ƒë∆∞·ª£c ƒë√≥ng.")
                break
            print("Consolog: V·∫´n c√≤n ti·∫øn tr√¨nh Telegram, ch·ªù 0.25 gi√¢y...")
            time.sleep(0.25)
        return True
    except Exception as e:
        print(f"Consolog [ERROR]: L·ªói khi t·ª± ƒë·ªông t·∫Øt Telegram: {e}")
        return False

# ƒê√≥ng Telegram trong lu·ªìng ri√™ng
def close_all_telegram_threaded():
    threading.Thread(target=auto_close_telegram, daemon=True).start()

# Ki·ªÉm tra c·∫≠p nh·∫≠t
def check_for_updates():
    print("Consolog: Ki·ªÉm tra c·∫≠p nh·∫≠t phi√™n b·∫£n...")
    try:
        url = f"https://api.github.com/repos/{GITHUB_USER}/{GITHUB_REPO}/releases/latest"
        response = requests.get(url)
        if response.status_code == 200:
            release_info = response.json()
            latest_version = release_info["tag_name"].lstrip("v")
            print(f"Consolog: Phi√™n b·∫£n m·ªõi nh·∫•t t·ª´ GitHub: {latest_version}")
            if version.parse(latest_version) > version.parse(CURRENT_VERSION):
                log_message(lang.get("update_available").format(version=latest_version))
                if messagebox.askyesno("C·∫≠p nh·∫≠t", lang.get("update_available").format(version=latest_version)):
                    print("Consolog [UPDATE]: Ng∆∞·ªùi d√πng ch·ªçn c·∫≠p nh·∫≠t phi√™n b·∫£n m·ªõi.")
                    assets = release_info.get("assets", [])
                    download_url = None
                    for asset in assets:
                        if asset["name"].lower().endswith(".exe"):
                            download_url = asset["browser_download_url"]
                            break
                    if not download_url and assets:
                        download_url = assets[0]["browser_download_url"]
                    if download_url:
                        print(f"Consolog [UPDATE]: B·∫Øt ƒë·∫ßu t·∫£i file c·∫≠p nh·∫≠t t·ª´ {download_url}")
                        download_update_with_progress(download_url)
                    else:
                        log_message("Kh√¥ng t√¨m th·∫•y file c·∫≠p nh·∫≠t tr√™n GitHub.")
                        print("Consolog [UPDATE ERROR]: Kh√¥ng t√¨m th·∫•y asset c·∫≠p nh·∫≠t.")
                else:
                    print("Consolog [UPDATE]: Ng∆∞·ªùi d√πng kh√¥ng c·∫≠p nh·∫≠t.")
            else:
                log_message(lang.get("no_updates"))
                print("Consolog: B·∫°n ƒëang d√πng phi√™n b·∫£n m·ªõi nh·∫•t.")
        else:
            log_message(lang.get("update_error"))
            print("Consolog: L·ªói ki·ªÉm tra c·∫≠p nh·∫≠t.")
    except Exception as e:
        log_message(f"L·ªói ki·ªÉm tra c·∫≠p nh·∫≠t: {e}")
        print(f"Consolog [ERROR]: L·ªói ki·ªÉm tra c·∫≠p nh·∫≠t: {e}")

# T·∫£i c·∫≠p nh·∫≠t v·ªõi thanh ti·∫øn tr√¨nh
def download_update_with_progress(download_url):
    local_filename = download_url.split("/")[-1]
    print(f"Consolog [UPDATE]: ƒêang t·∫£i xu·ªëng file: {local_filename}")
    progress_win = tk.Toplevel(root)
    progress_win.title("ƒêang t·∫£i c·∫≠p nh·∫≠t")
    progress_win.geometry("550x130")

    style = ttk.Style(progress_win)
    style.configure("Custom.Horizontal.TProgressbar", troughcolor="white", background="blue", thickness=20)

    tk.Label(progress_win, text=f"ƒêang t·∫£i: {local_filename}").pack(pady=5)
    progress_var = tk.DoubleVar(value=0)
    progress_bar = ttk.Progressbar(progress_win, variable=progress_var, maximum=100, length=500, style="Custom.Horizontal.TProgressbar")
    progress_bar.pack(pady=5)
    percent_label = tk.Label(progress_win, text="0%")
    percent_label.pack(pady=5)
    progress_win.update()

    try:
        response = requests.get(download_url, stream=True)
        total_length = response.headers.get('content-length')
        if total_length is None:
            log_message("Kh√¥ng x√°c ƒë·ªãnh ƒë∆∞·ª£c k√≠ch th∆∞·ªõc file c·∫≠p nh·∫≠t.")
            print("Consolog [UPDATE ERROR]: Kh√¥ng x√°c ƒë·ªãnh ƒë∆∞·ª£c content-length.")
            progress_win.destroy()
            return
        total_length = int(total_length)
        downloaded = 0
        with open(local_filename, "wb") as f:
            for chunk in response.iter_content(chunk_size=8192):
                if chunk:
                    f.write(chunk)
                    downloaded += len(chunk)
                    percent = (downloaded / total_length) * 100
                    progress_var.set(percent)
                    percent_label.config(text=f"{int(percent)}%")
                    progress_win.update_idletasks()

        progress_win.destroy()
        notify_win = tk.Toplevel(root)
        notify_win.title("T·∫£i c·∫≠p nh·∫≠t th√†nh c√¥ng")
        tk.Label(notify_win, text=f"ƒê√£ t·∫£i xong {local_filename}").pack(pady=10)

        def open_update_folder():
            folder = os.path.abspath(os.getcwd())
            try:
                os.startfile(folder)
            except Exception as e:
                log_message(f"L·ªói m·ªü th∆∞ m·ª•c: {e}")

        tk.Button(notify_win, text="M·ªü v·ªã tr√≠ file c·∫≠p nh·∫≠t", command=open_update_folder).pack(pady=5)
        tk.Button(notify_win, text="Close", command=notify_win.destroy).pack(pady=5)
        print("Consolog [UPDATE]: T·∫£i v·ªÅ c·∫≠p nh·∫≠t ho√†n t·∫•t.")
    except Exception as e:
        log_message(f"Failed to download update: {e}")
        print(f"Consolog [UPDATE ERROR]: L·ªói t·∫£i c·∫≠p nh·∫≠t: {e}")
        progress_win.destroy()

# S·∫Øp x·∫øp c·ª≠a s·ªï Telegram
def arrange_telegram_windows(custom_width=500, custom_height=504, for_check_live=False):
    print(f"Consolog: S·∫Øp x·∫øp c·ª≠a s·ªï Telegram v·ªõi k√≠ch th∆∞·ªõc {custom_width}x{custom_height}... For check live: {for_check_live}")
    my_hwnd = root.winfo_id()
    handles = []
    seen_pids = set()

    @ctypes.WINFUNCTYPE(ctypes.c_bool, ctypes.c_int, ctypes.c_int)
    def enum_callback(hwnd, lParam):
        if hwnd == my_hwnd:
            return True
        if user32.IsWindowVisible(hwnd):
            pid = ctypes.c_ulong()
            user32.GetWindowThreadProcessId(hwnd, ctypes.byref(pid))
            process_name = ""
            try:
                if psutil:
                    process = psutil.Process(pid.value)
                    process_name = process.name()
            except:
                pass
            if process_name.lower() == "telegram.exe":
                if for_check_live:
                    handles.append(hwnd)
                    print(f"Consolog: Th√™m c·ª≠a s·ªï HWND {hwnd} t·ª´ PID {pid.value} (check live mode)")
                else:
                    if pid.value not in seen_pids:
                        seen_pids.add(pid.value)
                        handles.append(hwnd)
                        print(f"Consolog: Th√™m c·ª≠a s·ªï HWND {hwnd} t·ª´ PID {pid.value}")
        return True

    user32.EnumWindows(enum_callback, 0)
    n = len(handles)
    print(f"Consolog: T√¨m th·∫•y {n} c·ª≠a s·ªï Telegram.")
    if n == 0:
        log_message("Kh√¥ng t√¨m th·∫•y c·ª≠a s·ªï Telegram n√†o.")
        return

    screen_width = user32.GetSystemMetrics(0)
    screen_height = user32.GetSystemMetrics(1)
    SWP_NOZORDER = 0x0004
    SWP_SHOWWINDOW = 0x0040

    if for_check_live:
        max_cols = screen_width // custom_width
        max_rows = screen_height // custom_height
        if max_cols < 1:
            max_cols = 1
        if max_rows < 1:
            max_rows = 1
        capacity = max_cols * max_rows

        if n <= capacity:
            for index, hwnd in enumerate(handles):
                row = index // max_cols
                col = index % max_cols
                x = col * custom_width
                y = row * custom_height
                user32.SetWindowPos(hwnd, None, x, y, custom_width, custom_height, SWP_NOZORDER | SWP_SHOWWINDOW)
                print(f"Consolog: Di chuy·ªÉn c·ª≠a s·ªï HWND {hwnd} ƒë·∫øn v·ªã tr√≠ ({x}, {y})")
        else:
            adjusted_width = screen_width // max_cols
            adjusted_height = screen_height // ((n + max_cols - 1) // max_cols)
            for index, hwnd in enumerate(handles):
                row = index // max_cols
                col = index % max_cols
                x = col * adjusted_width
                y = row * adjusted_height
                user32.SetWindowPos(hwnd, None, x, y, adjusted_width, adjusted_height, SWP_NOZORDER | SWP_SHOWWINDOW)
                print(f"Consolog: Di chuy·ªÉn v√† thu nh·ªè c·ª≠a s·ªï HWND {hwnd} ƒë·∫øn v·ªã tr√≠ ({x}, {y}) v·ªõi k√≠ch th∆∞·ªõc {adjusted_width}x{adjusted_height}")

        RDW_INVALIDATE = 0x1
        RDW_UPDATENOW = 0x100
        RDW_ALLCHILDREN = 0x80
        for hwnd in handles:
            user32.RedrawWindow(hwnd, None, None, RDW_INVALIDATE | RDW_UPDATENOW | RDW_ALLCHILDREN)
            time.sleep(0.25)
    else:
        max_cols = screen_width // custom_width
        max_rows = screen_height // custom_height
        if max_cols < 1:
            max_cols = 1
        if max_rows < 1:
            max_rows = 1
        capacity = max_cols * max_rows

        if n <= capacity:
            for index, hwnd in enumerate(handles):
                row = index // max_cols
                col = index % max_cols
                x = col * custom_width
                y = row * custom_height
                user32.SetWindowPos(hwnd, None, x, y, custom_width, custom_height, SWP_NOZORDER | SWP_SHOWWINDOW)
                time.sleep(0.25)
                print(f"Consolog: Di chuy·ªÉn c·ª≠a s·ªï HWND {hwnd} ƒë·∫øn v·ªã tr√≠ ({x}, {y})")
        else:
            offset_x = 30
            offset_y = 30
            for index, hwnd in enumerate(handles):
                x = (index % max_cols) * offset_x
                y = (index % max_rows) * offset_y
                if x + custom_width > screen_width:
                    x = screen_width - custom_width
                if y + custom_height > screen_height:
                    y = screen_height - custom_height
                user32.SetWindowPos(hwnd, None, x, y, custom_width, custom_height, SWP_NOZORDER | SWP_SHOWWINDOW)
                time.sleep(0.25)
                print(f"Consolog: (Cascade) Di chuy·ªÉn c·ª≠a s·ªï HWND {hwnd} ƒë·∫øn v·ªã tr√≠ ({x}, {y})")

    log_message(lang["arrange_result"].format(count=n))

# Ghi log
def log_message(msg):
    text_log.insert(tk.END, msg + "\n")
    text_log.see(tk.END)
    print(f"[LOG] {msg}")

# L∆∞u ƒë∆∞·ªùng d·∫´n Telegram
def save_telegram_path():
    global DEFAULT_TELEGRAM_PATH
    telegram_path = telegram_path_entry.get().strip()
    print(f"Consolog: L∆∞u Telegram Path t·ª´ m√†n h√¨nh ch√≠nh: {telegram_path}")
    if os.path.isfile(telegram_path):
        config["telegram_path"] = telegram_path
        DEFAULT_TELEGRAM_PATH = telegram_path
        save_config(config)
        log_message("ƒê√£ l∆∞u ƒë∆∞·ªùng d·∫´n Telegram!")
    else:
        log_message("ƒê∆∞·ªùng d·∫´n Telegram kh√¥ng h·ª£p l·ªá!")

# ƒê√≥ng ·ª©ng d·ª•ng
def on_closing():
    print("Consolog: ƒê√≥ng ·ª©ng d·ª•ng...")
    root.destroy()

# M·ªü c·ª≠a s·ªï Settings
def open_settings():
    print("Consolog: M·ªü c·ª≠a s·ªï Setting")
    popup = tk.Toplevel(root)
    popup.title("Setting - T√πy ch·ªânh s·∫Øp x·∫øp & API Keys")
    center_window(popup, 550, 450)

    lbl_info = tk.Label(popup, text="Nh·∫≠p k√≠ch th∆∞·ªõc c·ª≠a s·ªï s·∫Øp x·∫øp:\nx = (s·ªë c·ªôt) √ó Custom Width, y = (s·ªë h√†ng) √ó Custom Height", wraplength=530)
    lbl_info.pack(pady=10)

    frame_entries = tk.Frame(popup)
    frame_entries.pack(pady=5)
    tk.Label(frame_entries, text="Custom Width:").grid(row=0, column=0, padx=5, pady=5, sticky="e")
    entry_width = tk.Entry(frame_entries, width=10)
    entry_width.insert(0, str(arrange_width))
    entry_width.grid(row=0, column=1, padx=5, pady=5)
    tk.Label(frame_entries, text="Custom Height:").grid(row=1, column=0, padx=5, pady=5, sticky="e")
    entry_height = tk.Entry(frame_entries, width=10)
    entry_height.insert(0, str(arrange_height))
    entry_height.grid(row=1, column=1, padx=5, pady=5)

    tk.Label(popup, text="xAI API Key:").pack(pady=5)
    xai_key_entry = tk.Entry(popup, width=50)
    xai_key_entry.insert(0, XAI_API_KEY)
    xai_key_entry.pack(pady=5)

    tk.Label(popup, text="ChatGPT API Key:").pack(pady=5)
    chatgpt_key_entry = tk.Entry(popup, width=50)
    chatgpt_key_entry.insert(0, CHATGPT_API_KEY)
    chatgpt_key_entry.pack(pady=5)

    tk.Label(popup, text="LLM API Key:").pack(pady=5)
    llm_key_entry = tk.Entry(popup, width=50)
    llm_key_entry.insert(0, LLM_API_KEY)
    llm_key_entry.pack(pady=5)

    startup_var = tk.BooleanVar(value=config.get("startup", False))
    tk.Checkbutton(popup, text="Kh·ªüi ƒë·ªông c√πng Windows", variable=startup_var).pack(pady=5)

    def save_settings():
        global arrange_width, arrange_height, XAI_API_KEY, CHATGPT_API_KEY, LLM_API_KEY
        try:
            arrange_width = int(entry_width.get())
            arrange_height = int(entry_height.get())
            config["arrange_width"] = arrange_width
            config["arrange_height"] = arrange_height

            XAI_API_KEY = xai_key_entry.get().strip()
            CHATGPT_API_KEY = chatgpt_key_entry.get().strip()
            LLM_API_KEY = llm_key_entry.get().strip()

            if not LLM_API_KEY:
                log_message("LLM API Key kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng!")
                return

            config["xai_api_key"] = XAI_API_KEY
            config["chatgpt_api_key"] = CHATGPT_API_KEY
            config["llm_api_key"] = LLM_API_KEY
            config["startup"] = startup_var.get()
            print("Consolog: L∆∞u c·∫•u h√¨nh Settings")
            save_config(config)
            print("Consolog: ƒê√£ l∆∞u c·∫•u h√¨nh Setting")
            log_message("ƒê√£ l∆∞u c·∫•u h√¨nh!")
            popup.destroy()
            if config["startup"]:
                add_to_startup()
            else:
                remove_from_startup()
        except Exception as e:
            log_message(f"Gi√° tr·ªã kh√¥ng h·ª£p l·ªá: {e}")
            print(f"Consolog [ERROR]: L·ªói l∆∞u c·∫•u h√¨nh Setting: {e}")

    btn_save = tk.Button(popup, text="Save", command=save_settings)
    btn_save.pack(pady=10)
    popup.transient(root)
    popup.grab_set()
    root.wait_window(popup)

# Th√™m v√†o startup
def add_to_startup():
    try:
        import winshell
        startup_folder = winshell.startup()
        shortcut_path = os.path.join(startup_folder, "TelegramAuto.lnk")
        target = os.path.abspath(__file__)
        winshell.CreateShortcut(
            Path=shortcut_path,
            Target=target,
            Icon=(target, 0),
            Description="TelegramAuto Startup"
        )
        print("Consolog: ƒê√£ th√™m ·ª©ng d·ª•ng v√†o startup.")
    except Exception as e:
        log_message(f"L·ªói khi th√™m v√†o startup: {e}")

# X√≥a kh·ªèi startup
def remove_from_startup():
    try:
        import winshell
        startup_folder = winshell.startup()
        shortcut_path = os.path.join(startup_folder, "TelegramAuto.lnk")
        if os.path.exists(shortcut_path):
            os.remove(shortcut_path)
            print("Consolog: ƒê√£ x√≥a ·ª©ng d·ª•ng kh·ªèi startup.")
    except Exception as e:
        log_message(f"L·ªói khi x√≥a kh·ªèi startup: {e}")

# CƒÉn gi·ªØa c·ª≠a s·ªï
def center_window(win, width, height):
    win.update_idletasks()
    screen_width = win.winfo_screenwidth()
    screen_height = win.winfo_screenheight()
    x = (screen_width - width) // 2
    y = (screen_height - height) // 2
    win.geometry(f"{width}x{height}+{x}+{y}")

# Ch·ªçn ng√¥n ng·ªØ
def select_language():
    lang_window = tk.Tk()
    lang_window.title(languages["en"]["lang_select_title"])
    center_window(lang_window, 400, 200)

    tk.Label(lang_window, text="Select Language / ÈÄâÊã©ËØ≠Ë®Ä / Ch·ªçn ng√¥n ng·ªØ:", font=("Arial Unicode MS", 12)).pack(pady=10)
    language_var = tk.StringVar(value="en")
    for code in ["vi", "en", "zh"]:
        tk.Radiobutton(
            lang_window,
            text=languages[code]["lang_" + code],
            variable=language_var,
            value=code,
            font=("Arial Unicode MS", 10)
        ).pack(anchor="w", padx=20)

    tk.Label(lang_window, text=VERSION_INFO, font=("Arial Unicode MS", 8)).pack(pady=5)
    tk.Button(lang_window, text="OK", command=lambda: set_language(language_var, lang_window), font=("Arial Unicode MS", 10)).pack(pady=10)
    lang_window.mainloop()

# Thi·∫øt l·∫≠p ng√¥n ng·ªØ
def set_language(language_var, window):
    global lang
    selected = language_var.get()
    lang = languages[selected]
    window.destroy()
    print("Consolog: Ng∆∞·ªùi d√πng ch·ªçn ng√¥n ng·ªØ xong, kh·ªüi t·∫°o giao di·ªán ch√≠nh.")
    init_main_ui()

# Hi·ªÉn th·ªã splash screen
def show_splash_screen():
    splash = tk.Tk()
    splash.overrideredirect(True)
    width = 400
    height = 200
    screen_width = splash.winfo_screenwidth()
    screen_height = splash.winfo_screenheight()
    x = (screen_width - width) // 2
    y = (screen_height - height) // 2
    splash.geometry(f"{width}x{height}+{x}+{y}")
    
    tk.Label(splash, text="Loading, please wait...", font=("Arial Unicode MS", 12)).pack(pady=20)
    progress_var = tk.DoubleVar(value=0)
    progress_bar = ttk.Progressbar(splash, variable=progress_var, maximum=100, length=300)
    progress_bar.pack(pady=20)
    percent_label = tk.Label(splash, text="0%", font=("Arial Unicode MS", 10))
    percent_label.pack(pady=10)
    
    print("Consolog: Splash screen hi·ªÉn th·ªã.")
    threading.Thread(target=lambda: load_tool(splash, progress_var, percent_label), daemon=True).start()
    splash.mainloop()

# Load tool trong splash screen
def load_tool(splash, progress_var, percent_label):
    start_time = time.time()
    print("Consolog: B·∫Øt ƒë·∫ßu load tool...")
    steps = ["Ki·ªÉm tra c·∫•u h√¨nh", "T·∫£i d·ªØ li·ªáu", "Kh·ªüi t·∫°o giao di·ªán"]
    for i, step in enumerate(steps):
        print(f"Consolog: ƒêang th·ª±c hi·ªán: {step}")
        time.sleep(1.67)
        progress = (i + 1) / len(steps) * 100
        splash.after(0, lambda p=progress: progress_var.set(p))
        splash.after(0, lambda p=progress: percent_label.config(text=f"{int(p)}%"))
    end_time = time.time()
    print(f"Consolog: Tool ƒë√£ load xong sau {end_time - start_time:.2f} gi√¢y.")
    splash.after(0, lambda: finish_splash(splash))

# K·∫øt th√∫c splash screen
def finish_splash(splash):
    splash.destroy()
    print("Consolog: Splash screen k·∫øt th√∫c, hi·ªÉn th·ªã giao di·ªán ch·ªçn ng√¥n ng·ªØ.")
    select_language()

# Kh·ªüi t·∫°o giao di·ªán ch√≠nh
def init_main_ui():
    global root, text_log, telegram_path_entry, DEFAULT_TELEGRAM_PATH, XAI_API_KEY, CHATGPT_API_KEY, LLM_API_KEY
    root = tk.Tk()
    root.title(lang["title"])
    center_window(root, 650, 800)

    default_font = tkFont.nametofont("TkDefaultFont")
    default_font.configure(family="Arial Unicode MS", size=10)
    root.option_add("*Font", default_font)

    threading.Thread(target=check_for_updates, daemon=True).start()

    print("Consolog: Ki·ªÉm tra Telegram Path t·ª´ m√†n h√¨nh ch√≠nh thay v√¨ Settings")
    tk.Label(root, text=lang["title"], font=("Arial Unicode MS", 14, "bold")).pack(pady=10)

    frame_telegram_path = tk.Frame(root)
    frame_telegram_path.pack(pady=5)
    tk.Label(frame_telegram_path, text=lang["telegram_path_label"]).pack(side=tk.LEFT, padx=5)
    telegram_path_entry = tk.Entry(frame_telegram_path, width=50)
    telegram_path_entry.insert(0, DEFAULT_TELEGRAM_PATH)
    telegram_path_entry.pack(side=tk.LEFT, padx=5)
    print("Consolog [ƒê√É CH·ªàNH S·ª¨A]: ƒê√£ ·∫©n n√∫t Save Telegram Path tr√™n giao di·ªán ch√≠nh")

    if not telegram_path_entry.get():
        log_message("ƒê∆∞·ªùng d·∫´n Telegram ch∆∞a ƒë∆∞·ª£c thi·∫øt l·∫≠p. Vui l√≤ng nh·∫≠p v√† l∆∞u!")
        save_telegram_path()
        if not telegram_path_entry.get():
            log_message("ƒê∆∞·ªùng d·∫´n Telegram l√† b·∫Øt bu·ªôc ƒë·ªÉ ti·∫øp t·ª•c!")
            return

    print("Consolog: Ki·ªÉm tra API Keys")
    if not XAI_API_KEY or not CHATGPT_API_KEY or not LLM_API_KEY:
        log_message("API Key ch∆∞a ƒë∆∞·ª£c thi·∫øt l·∫≠p. Vui l√≤ng nh·∫≠p trong Settings!")
        open_settings()
        if not XAI_API_KEY or not CHATGPT_API_KEY or not LLM_API_KEY:
            log_message("API Key l√† b·∫Øt bu·ªôc ƒë·ªÉ ti·∫øp t·ª•c!")
            return

    frame_buttons = tk.Frame(root)
    frame_buttons.pack(pady=5)

    tk.Button(frame_buttons, text=lang["close_telegram"], command=close_all_telegram_threaded, width=18).grid(row=0, column=0, padx=5, pady=5)
    tk.Button(frame_buttons, text=lang["arrange_telegram"], command=lambda: arrange_telegram_windows(arrange_width, arrange_height), width=18).grid(row=0, column=1, padx=5, pady=5)
    tk.Button(frame_buttons, text=lang["setting"], command=open_settings, width=18).grid(row=0, column=2, padx=5, pady=5)
    tk.Button(frame_buttons, text=lang["check_update"], command=check_for_updates, width=18).grid(row=1, column=1, padx=5, pady=5)

    frame_log = tk.Frame(root)
    frame_log.pack(pady=10)
    tk.Label(frame_log, text=lang["log_label"]).pack()
    text_log = tk.Text(frame_log, width=70, height=10)
    text_log.pack()

    tk.Label(root, text=VERSION_INFO, font=("Arial Unicode MS", 8)).pack(side="bottom", fill="x", pady=5)
    root.protocol("WM_DELETE_WINDOW", on_closing)

    try:
        set_root(root)
        set_sam_translate_globals(XAI_API_KEY, CHATGPT_API_KEY, LLM_API_KEY, TRANSLATION_ONLY, DEFAULT_TARGET_LANG)
        create_sam_translate()
        create_sam_mini_chat()
        print("Consolog: Sam Translate v√† Sam Mini Chat ƒë√£ ƒë∆∞·ª£c kh·ªüi ƒë·ªông t·ª± ƒë·ªông khi ·ª©ng d·ª•ng b·∫Øt ƒë·∫ßu.")
    except Exception as e:
        print(f"Consolog [ERROR]: L·ªói khi kh·ªüi ƒë·ªông Sam Translate ho·∫∑c Sam Mini Chat: {e}")

    root.mainloop()

# Kh·ªüi ch·∫°y ·ª©ng d·ª•ng
print("Consolog: ·ª®ng d·ª•ng kh·ªüi ch·∫°y, hi·ªÉn th·ªã splash screen.")
show_splash_screen()